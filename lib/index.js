// Generated by CoffeeScript 2.3.2
var cleanup, fs, handle_error, k, kdestroy, kinit, kvno, spnego;

k = require('../build/Release/krb5');

fs = require('fs');

cleanup = function(ctx, princ, ccache) {
  if (princ) {
    k.krb5_free_principal_sync(ctx, princ);
  }
  if (ccache) {
    return k.krb5_cc_close(ctx, ccache, function(err) {
      if (ctx) {
        return k.krb5_free_context_sync(ctx);
      }
    });
  } else {
    if (ctx) {
      return k.krb5_free_context_sync(ctx);
    }
  }
};

handle_error = function(callback, err, ctx, princ, ccache) {
  if (!err) {
    return err;
  }
  err = k.krb5_get_error_message_sync(ctx, err);
  cleanup(ctx, princ, ccache);
  return callback(Error(err));
};

kinit = function(options, callback) {
  var do_ccache, do_creds, do_init, do_principal, do_realm, split;
  if (!options.principal) {
    return callback(Error('Please specify principal for kinit'));
  }
  if (!(options.password || options.keytab)) {
    return callback(Error('Please specify password or keytab for kinit'));
  }
  if (options.principal.indexOf('@') !== -1) {
    split = options.principal.split('@');
    options.principal = split[0];
    options.realm = split[1];
  }
  do_init = function() {
    return k.krb5_init_context(function(err, ctx) {
      if (err) {
        return handle_error(callback, err);
      }
      return do_realm(ctx);
    });
  };
  do_realm = function(ctx) {
    if (!options.realm) {
      return k.krb5_get_default_realm(ctx, function(err, realm) {
        if (err) {
          return handle_error(callback, err, ctx);
        }
        options.realm = realm;
        return do_principal(ctx);
      });
    } else {
      return do_principal(ctx);
    }
  };
  do_principal = function(ctx) {
    return k.krb5_build_principal(ctx, options.realm.length, options.realm, options.principal, function(err, princ) {
      if (err) {
        return handle_error(callback, err, ctx);
      }
      return do_ccache(ctx, princ);
    });
  };
  do_ccache = function(ctx, princ) {
    if (options.ccname) {
      if (options.ccname.indexOf(':KEYRING') !== -1) {
        cleanup(ctx, princ);
        return callback(Error('KEYRING method not supported.'));
      }
      return k.krb5_cc_resolve(ctx, options.ccname, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, princ);
        }
        return do_creds(ctx, princ, ccache);
      });
    } else {
      return k.krb5_cc_default(ctx, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, princ);
        }
        return do_creds(ctx, princ, ccache);
      });
    }
  };
  do_creds = function(ctx, princ, ccache) {
    var ccname, get_creds_keytab, get_creds_password, store_creds;
    ccname = k.krb5_cc_get_name_sync(ctx, ccache);
    fs.exists(ccname, function(exists) {
      if (!exists) {
        return k.krb5_cc_initialize(ctx, ccache, princ, function(err) {
          if (err) {
            return handle_error(callback, err, ctx, princ);
          }
          if (options.password) {
            return get_creds_password();
          } else {
            return get_creds_keytab();
          }
        });
      } else {
        if (options.password) {
          return get_creds_password();
        } else {
          return get_creds_keytab();
        }
      }
    });
    get_creds_password = function() {
      return k.krb5_get_init_creds_password(ctx, princ, options.password, function(err, creds) {
        if (err) {
          return handle_error(callback, err, ctx, princ, ccache);
        }
        return store_creds(creds);
      });
    };
    get_creds_keytab = function() {
      return k.krb5_kt_resolve(ctx, options.keytab, function(err, kt) {
        if (err) {
          return handle_error(callback, err, ctx, princ, ccache);
        }
        return k.krb5_get_init_creds_keytab(ctx, princ, kt, 0, function(err, creds) {
          if (err) {
            return handle_error(callback, err, ctx, princ, ccache);
          }
          return store_creds(creds);
        });
      });
    };
    return store_creds = function(creds) {
      return k.krb5_cc_store_cred(ctx, ccache, creds, function(err) {
        if (err) {
          return handle_error(callback, err, ctx, princ, ccache);
        }
        cleanup(ctx, princ, ccache);
        return callback(void 0, ccname);
      });
    };
  };
  return do_init();
};

kdestroy = function(options, callback) {
  var do_ccache, do_destroy;
  k.krb5_init_context(function(err, ctx) {
    if (err) {
      return handle_error(callback, err, ctx);
    }
    return do_ccache(ctx);
  });
  do_ccache = function(ctx) {
    if (options.ccname) {
      return k.krb5_cc_resolve(ctx, options.ccname, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return do_destroy(ctx, ccache);
      });
    } else {
      return k.krb5_cc_default(ctx, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return do_destroy(ctx, ccache);
      });
    }
  };
  return do_destroy = function(ctx, ccache) {
    return k.krb5_cc_destroy(ctx, ccache, function(err) {
      if (err) {
        return handle_error(callback, err, ctx);
      }
      return callback(void 0);
    });
  };
};

kvno = function(options, callback) {
  var do_ccache, do_creds, do_for_user, do_keytab, do_me, do_parse_name;
  if (!options.service) {
    return callback(Error('Please specify service for kvno'));
  }
  k.krb5_init_context(function(err, ctx) {
    if (err) {
      return handle_error(callback, err, ctx);
    }
    return do_ccache(ctx);
  });
  do_ccache = function(ctx) {
    if (options.ccname) {
      return k.krb5_cc_resolve(ctx, options.ccname, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx);
        }
        return do_keytab(ctx, ccache);
      });
    } else {
      return k.krb5_cc_default(ctx, function(err, ccache) {
        if (err) {
          return handle_error(callback, err, ctx);
        }
        return do_keytab(ctx, ccache);
      });
    }
  };
  do_keytab = function(ctx, ccache) {
    if (options.keytab) {
      return k.krb5_kt_resolve(ctx, options.keytab, function(err, keytab) {
        if (err) {
          return handle_error(callback, err, ctx);
        }
        return do_for_user(ctx, ccache, keytab);
      });
    } else {
      return do_for_user(ctx, ccache, null);
    }
  };
  do_for_user = function(ctx, ccache, keytab) {
    if (options.foruser) {
      return k.krb5_parse_name_flags(ctx, options.foruser, function(err, foruser_princ) {
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return do_me(ctx, ccache, keytab, foruser_princ);
      });
    } else {
      return do_me(ctx, ccache, keytab, null);
    }
  };
  // unhandled options
  // do_u2u
  // do_etype
  do_me = function(ctx, ccache, keytab, foruser_princ) {
    return k.krb5_cc_get_principal(ctx, ccache, function(err, me) {
      if (err) {
        return handle_error(callback, err, ctx, null, ccache);
      }
      return do_parse_name(ctx, ccache, keytab, foruser_princ, me);
    });
  };
  do_parse_name = function(ctx, ccache, keytab, foruser_princ, me) {
    if (options.sname) {
      return k.krb5_sname_to_principal(ctx, options.service, options.sname, function(err, server) {
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return do_creds(ctx, ccache, keytab, foruser_princ, me, server);
      });
    } else {
      return k.krb5_parse_name(ctx, options.service, function(err, server) {
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return do_creds(ctx, ccache, keytab, foruser_princ, me, server);
      });
    }
  };
  return do_creds = function(ctx, ccache, keytab, foruser_princ, me, server) {
    var opt;
    opt = 0;
    if (foruser_princ === !null) {
      // TODO: error if !krb5_principal_compare(ctx, me, server)
      return k.krb5_get_credentials_for_user(ctx, opt, ccache, foruser_princ, me, null, function(err, out_creds) { // unhandled in_cred_etype, in_cred_u2u // in_cred_client, // in_cred_server
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return callback(void 0);
      });
    } else {
      return k.krb5_get_credentials(ctx, opt, ccache, me, server, function(err, out_creds) { // unhandled in_cred_etype, in_cred_u2u // in_cred_client, // in_cred_server
        if (err) {
          return handle_error(callback, err, ctx, null, ccache);
        }
        return callback(void 0);
      });
    }
  };
};

spnego = function(options, callback) {
  var input_name_type, service;
  if (options.ccname == null) {
    options.ccname = "";
  }
  if (options.service_principal) {
    input_name_type = 'GSS_C_NT_USER_NAME';
    service = options.service_principal;
  } else if (options.service_fqdn || options.hostbased_service) {
    input_name_type = 'GSS_C_NT_HOSTBASED_SERVICE';
    service = options.service_fqdn || options.hostbased_service;
    if (!/.*[@]/.test(service)) {
      service = `HTTP@${service}`;
    }
  } else {
    return callback(Error('Missing option "service_principal" or "hostbased_service"'));
  }
  return k.generate_spnego_token(service, input_name_type, options.ccname, function(err, token) {
    return callback((err === "" ? void 0 : Error(err)), token);
  });
};

module.exports = {
  kinit: function(options, callback) {
    if (typeof callback === 'function') {
      return kinit(options, callback);
    }
    return new Promise(function(resolve, reject) {
      return kinit(options, function(err, ccname) {
        if (err) {
          reject(err);
        }
        return resolve(ccname);
      });
    });
  },
  spnego: function(options, callback) {
    if (typeof callback === 'function') {
      return spnego(options, callback);
    }
    return new Promise(function(resolve, reject) {
      return spnego(options, function(err, token) {
        if (err) {
          reject(err);
        }
        return resolve(token);
      });
    });
  },
  kdestroy: function(options, callback) {
    if (options == null) {
      options = {};
    }
    if (typeof options === 'function') {
      callback = options;
      return kdestroy({}, callback);
    } else {
      if (typeof callback === 'function') {
        return kdestroy(options, callback);
      }
      return new Promise(function(resolve, reject) {
        return kdestroy(options, function(err) {
          if (err) {
            reject(err);
          }
          return resolve();
        });
      });
    }
  },
  kvno: function(options, callback) {
    if (typeof callback === 'function') {
      return kvno(options, callback);
    }
    return new Promise(function(resolve, reject) {
      return kvno(options, function(err) {
        if (err) {
          reject(err);
        }
        return resolve();
      });
    });
  }
};
